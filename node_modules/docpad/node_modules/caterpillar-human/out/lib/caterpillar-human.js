// Generated by CoffeeScript 1.6.2
var Human, ansiColors, ansiStyles, err, util, _ref,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

util = require('util');

try {
  ansiColors = require('ansicolors');
  ansiStyles = require('ansistyles');
} catch (_error) {
  err = _error;
  ansiColors = null;
  ansiStyles = null;
}

Human = (function(_super) {
  __extends(Human, _super);

  function Human() {
    this.format = __bind(this.format, this);
    this._transform = __bind(this._transform, this);    _ref = Human.__super__.constructor.apply(this, arguments);
    return _ref;
  }

  Human.prototype.config = {
    color: true,
    level: null,
    colors: {
      0: 'red',
      1: 'red',
      2: 'red',
      3: 'red',
      4: 'yellow',
      5: 'yellow',
      6: 'green',
      7: 'green'
    }
  };

  Human.prototype._transform = function(chunk, encoding, next) {
    var entry, message;

    entry = JSON.parse(chunk.toString());
    message = this.format(entry);
    return next(null, message);
  };

  Human.prototype.getColor = function(levelNumber) {
    var color, _ref1;

    color = ((_ref1 = this.config.colors) != null ? _ref1[levelNumber] : void 0) || false;
    return color;
  };

  Human.prototype.padLeft = function(padding, size, msg) {
    var i, _i, _ref1;

    padding = String(padding);
    msg = String(msg);
    if (msg.length < size) {
      for (i = _i = 0, _ref1 = size - msg.length; 0 <= _ref1 ? _i < _ref1 : _i > _ref1; i = 0 <= _ref1 ? ++_i : --_i) {
        msg = padding + msg;
      }
    }
    return msg;
  };

  Human.prototype.padRight = function(padding, size, msg) {
    var i, _i, _ref1;

    padding = String(padding);
    msg = String(msg);
    if (msg.length < size) {
      for (i = _i = 0, _ref1 = size - msg.length; 0 <= _ref1 ? _i < _ref1 : _i > _ref1; i = 0 <= _ref1 ? ++_i : --_i) {
        msg += padding;
      }
    }
    return msg;
  };

  Human.prototype.formatArguments = function(args) {
    var index, parts, text, value, _i, _len;

    parts = [];
    for (index = _i = 0, _len = args.length; _i < _len; index = ++_i) {
      value = args[index];
      parts[index] = typeof value === 'string' ? value : util.inspect(value, false, 10);
    }
    text = parts.join(' ');
    return text;
  };

  Human.prototype.formatDate = function(now) {
    var date, hours, minutes, month, ms, result, seconds, year;

    now = new Date(now);
    year = now.getFullYear();
    month = this.padLeft('0', 2, now.getMonth() + 1);
    date = this.padLeft('0', 2, now.getDate());
    hours = this.padLeft('0', 2, now.getHours());
    minutes = this.padLeft('0', 2, now.getMinutes());
    seconds = this.padLeft('0', 2, now.getSeconds());
    ms = this.padLeft('0', 3, now.getMilliseconds());
    result = "" + year + "-" + month + "-" + date + " " + hours + ":" + minutes + ":" + seconds + "." + ms;
    return result;
  };

  Human.prototype.format = function(entry) {
    var config, debugFormatter, debugMode, debugString, entryString, levelFormatter, levelString, messageString, result, seperator, textFormatter, useColors;

    config = this.getConfig();
    entry.color = this.getColor(entry.levelNumber);
    entry.timestamp = this.formatDate(entry.date);
    entry.text = this.formatArguments(entry.args);
    useColors = this.config.color === true;
    debugMode = config.level === 7;
    result = null;
    if (entry.text) {
      levelFormatter = useColors && ((ansiColors != null ? ansiColors[entry.color] : void 0) || (ansiStyles != null ? ansiStyles[entry.color] : void 0));
      textFormatter = false && debugMode && useColors && (ansiStyles != null ? ansiStyles.bright : void 0);
      debugFormatter = debugMode && useColors && (ansiStyles != null ? ansiStyles.dim : void 0);
      levelString = entry.levelName + ':';
      if (levelFormatter) {
        levelString = levelFormatter(levelString);
      }
      entryString = entry.text;
      if (textFormatter) {
        entryString = textFormatter(entryString);
      }
      messageString = "" + levelString + " " + entryString;
      if (debugMode) {
        seperator = '\n    ';
        debugString = "â†’ [" + entry.timestamp + "] [" + entry.file + ":" + entry.line + "] [" + entry.method + "]";
        if (debugFormatter) {
          debugString = debugFormatter(debugString);
        }
        result = "" + messageString + seperator + debugString + "\n";
      } else {
        result = messageString + '\n';
      }
    }
    return result;
  };

  return Human;

})(require('caterpillar').Transform);

module.exports = {
  Human: Human
};
